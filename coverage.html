
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>etlmon: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/etlmon/etlmon/cmd/etlmon/main.go (0.0%)</option>
				
				<option value="file1">github.com/etlmon/etlmon/internal/aggregator/aggregator.go (93.5%)</option>
				
				<option value="file2">github.com/etlmon/etlmon/internal/aggregator/functions.go (100.0%)</option>
				
				<option value="file3">github.com/etlmon/etlmon/internal/aggregator/window.go (100.0%)</option>
				
				<option value="file4">github.com/etlmon/etlmon/internal/collector/collector.go (100.0%)</option>
				
				<option value="file5">github.com/etlmon/etlmon/internal/collector/cpu.go (100.0%)</option>
				
				<option value="file6">github.com/etlmon/etlmon/internal/collector/disk.go (85.4%)</option>
				
				<option value="file7">github.com/etlmon/etlmon/internal/collector/disk_methods.go (84.1%)</option>
				
				<option value="file8">github.com/etlmon/etlmon/internal/collector/memory.go (87.5%)</option>
				
				<option value="file9">github.com/etlmon/etlmon/internal/config/config.go (77.4%)</option>
				
				<option value="file10">github.com/etlmon/etlmon/internal/storage/sqlite.go (80.4%)</option>
				
				<option value="file11">github.com/etlmon/etlmon/internal/tui/app.go (44.6%)</option>
				
				<option value="file12">github.com/etlmon/etlmon/internal/tui/history.go (91.3%)</option>
				
				<option value="file13">github.com/etlmon/etlmon/internal/tui/realtime.go (97.8%)</option>
				
				<option value="file14">github.com/etlmon/etlmon/internal/tui/status.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/etlmon/etlmon/internal/aggregator"
        "github.com/etlmon/etlmon/internal/collector"
        "github.com/etlmon/etlmon/internal/config"
        "github.com/etlmon/etlmon/internal/storage"
        "github.com/etlmon/etlmon/internal/tui"
)

var (
        version = "0.1.0"
        commit  = "dev"
)

func main() <span class="cov0" title="0">{
        // Parse flags
        configPath := flag.String("config", "", "Path to configuration file (required)")
        dbPath := flag.String("db", "", "Override database path from config")
        showVersion := flag.Bool("version", false, "Show version information")
        flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("etlmon version %s (%s)\n", version, commit)
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if *configPath == "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, "Error: --config flag is required")
                flag.Usage()
                os.Exit(1)
        }</span>

        // Load configuration
        <span class="cov0" title="0">cfg, err := config.Load(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid configuration: %v", err)
        }</span>

        // Override database path if specified
        <span class="cov0" title="0">if *dbPath != "" </span><span class="cov0" title="0">{
                cfg.Database.Path = *dbPath
        }</span>

        // Initialize storage
        <span class="cov0" title="0">store, err := storage.NewSQLiteStore(cfg.Database.Path)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create storage: %v", err)
        }</span>
        <span class="cov0" title="0">defer store.Close()

        if err := store.Initialize(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize storage: %v", err)
        }</span>

        // Get window durations
        <span class="cov0" title="0">windows, err := cfg.GetWindowDurations()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to parse windows: %v", err)
        }</span>

        // Create aggregator
        <span class="cov0" title="0">agg := aggregator.NewAggregator(windows, cfg.Aggregations)

        // Create collector manager
        collectorMgr := collector.NewManager(cfg.Interval)

        // Register collectors based on config
        for _, resource := range cfg.Resources </span><span class="cov0" title="0">{
                switch resource </span>{
                case "cpu":<span class="cov0" title="0">
                        collectorMgr.Register(collector.NewCPUCollector())</span>
                case "memory":<span class="cov0" title="0">
                        collectorMgr.Register(collector.NewMemoryCollector())</span>
                case "disk":<span class="cov0" title="0">
                        collectorMgr.Register(collector.NewDiskCollectorWithConfig(cfg.Disk))</span>
                }
        }

        // Create TUI
        <span class="cov0" title="0">app := tui.NewApp()
        app.SetStore(store)

        // Create context for cancellation
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Channel for metrics from collector
        metricsChan := make(chan []collector.Metric, 100)

        // Start collector in goroutine
        go func() </span><span class="cov0" title="0">{
                collectorMgr.Start(ctx, func(metrics []collector.Metric) </span><span class="cov0" title="0">{
                        select </span>{
                        case metricsChan &lt;- metrics:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                                // Drop metrics if channel is full (backpressure)
                        }
                })
        }()

        // Start aggregation checker in goroutine
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(time.Second)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case metrics := &lt;-metricsChan:<span class="cov0" title="0">
                                // Add metrics to aggregator
                                for _, m := range metrics </span><span class="cov0" title="0">{
                                        agg.Add(m)
                                }</span>

                                // Update TUI with realtime metrics
                                <span class="cov0" title="0">app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                        app.OnMetricsCollected(metrics)
                                }</span>)

                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Check for completed windows
                                results := agg.CheckWindows(time.Now())
                                if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                        // Save to storage
                                        batch := make([]*storage.AggregatedMetric, len(results))
                                        for i, r := range results </span><span class="cov0" title="0">{
                                                batch[i] = &amp;storage.AggregatedMetric{
                                                        Timestamp:       r.Timestamp.Unix(),
                                                        ResourceType:    r.ResourceType,
                                                        MetricName:      r.MetricName,
                                                        AggregatedValue: r.Value,
                                                        WindowSize:      tui.FormatDuration(r.WindowSize),
                                                        AggregationType: r.AggregationType,
                                                        Labels:          r.Labels,
                                                }
                                        }</span>

                                        <span class="cov0" title="0">if err := store.SaveBatch(batch); err != nil </span><span class="cov0" title="0">{
                                                log.Printf("Failed to save metrics: %v", err)
                                        }</span>

                                        // Update TUI with aggregation results
                                        <span class="cov0" title="0">app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                                app.OnAggregationComplete(results)
                                        }</span>)
                                }
                        }
                }
        }()

        // Handle shutdown signal
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                &lt;-sigChan
                log.Println("Shutting down...")
                cancel()
                app.Stop()
        }</span>()

        // Run TUI (blocking)
        <span class="cov0" title="0">if err := app.Run(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("TUI error: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("etlmon stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package aggregator

import (
        "sync"
        "time"

        "github.com/etlmon/etlmon/internal/collector"
)

// AggregationResult holds the result of an aggregation
type AggregationResult struct {
        ResourceType    string
        MetricName      string
        Value           float64
        WindowSize      time.Duration
        AggregationType string
        Timestamp       time.Time // Window end time
        Labels          string    // JSON-encoded labels map (empty for cpu/memory)
}

// Aggregator manages time-window aggregation of metrics
type Aggregator struct {
        buffers  map[time.Duration]*MetricBuffer
        aggTypes []string
        mu       sync.RWMutex
}

// NewAggregator creates a new aggregator with the specified windows and aggregation types
func NewAggregator(windows []time.Duration, aggTypes []string) *Aggregator <span class="cov8" title="1">{
        buffers := make(map[time.Duration]*MetricBuffer)
        for _, w := range windows </span><span class="cov8" title="1">{
                buffers[w] = NewMetricBuffer(w)
        }</span>

        <span class="cov8" title="1">return &amp;Aggregator{
                buffers:  buffers,
                aggTypes: aggTypes,
        }</span>
}

// Add adds a metric to all window buffers
func (a *Aggregator) Add(m collector.Metric) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        for _, buf := range a.buffers </span><span class="cov8" title="1">{
                buf.Add(m)
        }</span>
}

// CheckWindows checks if any windows are complete and returns aggregation results
func (a *Aggregator) CheckWindows(now time.Time) []AggregationResult <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        var results []AggregationResult

        for duration, buf := range a.buffers </span><span class="cov8" title="1">{
                if buf.IsWindowComplete(now) </span><span class="cov8" title="1">{
                        // Get all unique resource/metric keys
                        keys := buf.GetResourceMetricKeys()

                        for _, key := range keys </span><span class="cov8" title="1">{
                                values := buf.GetValues(key)
                                if len(values) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Apply each aggregation function
                                <span class="cov8" title="1">for _, aggType := range a.aggTypes </span><span class="cov8" title="1">{
                                        fn, ok := AggregationFuncs[aggType]
                                        if !ok </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">results = append(results, AggregationResult{
                                                ResourceType:    key.ResourceType,
                                                MetricName:      key.MetricName,
                                                Value:           fn(values),
                                                WindowSize:      duration,
                                                AggregationType: aggType,
                                                Timestamp:       buf.WindowEnd(),
                                                Labels:          key.Labels,
                                        })</span>
                                }
                        }

                        // Reset window for next period
                        <span class="cov8" title="1">buf.ResetWindow(now)</span>
                }
        }

        <span class="cov8" title="1">return results</span>
}

// GetWindowDurations returns all configured window durations
func (a *Aggregator) GetWindowDurations() []time.Duration <span class="cov8" title="1">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        durations := make([]time.Duration, 0, len(a.buffers))
        for d := range a.buffers </span><span class="cov8" title="1">{
                durations = append(durations, d)
        }</span>
        <span class="cov8" title="1">return durations</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package aggregator

// Avg calculates the average of a slice of float64
func Avg(values []float64) float64 <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">var sum float64
        for _, v := range values </span><span class="cov8" title="1">{
                sum += v
        }</span>
        <span class="cov8" title="1">return sum / float64(len(values))</span>
}

// Max returns the maximum value from a slice of float64
func Max(values []float64) float64 <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">max := values[0]
        for _, v := range values[1:] </span><span class="cov8" title="1">{
                if v &gt; max </span><span class="cov8" title="1">{
                        max = v
                }</span>
        }
        <span class="cov8" title="1">return max</span>
}

// Min returns the minimum value from a slice of float64
func Min(values []float64) float64 <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">min := values[0]
        for _, v := range values[1:] </span><span class="cov8" title="1">{
                if v &lt; min </span><span class="cov8" title="1">{
                        min = v
                }</span>
        }
        <span class="cov8" title="1">return min</span>
}

// Last returns the last value from a slice of float64
func Last(values []float64) float64 <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return values[len(values)-1]</span>
}

// AggregationFunc is a type for aggregation functions
type AggregationFunc func([]float64) float64

// AggregationFuncs maps aggregation type names to functions
var AggregationFuncs = map[string]AggregationFunc{
        "avg":  Avg,
        "max":  Max,
        "min":  Min,
        "last": Last,
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package aggregator

import (
        "encoding/json"
        "sort"
        "sync"
        "time"

        "github.com/etlmon/etlmon/internal/collector"
)

// MetricBuffer holds metrics for a specific time window
type MetricBuffer struct {
        duration    time.Duration
        windowStart time.Time
        metrics     []collector.Metric
        mu          sync.RWMutex
}

// NewMetricBuffer creates a new buffer for the given window duration
func NewMetricBuffer(duration time.Duration) *MetricBuffer <span class="cov8" title="1">{
        return &amp;MetricBuffer{
                duration:    duration,
                windowStart: time.Now().Truncate(duration),
                metrics:     make([]collector.Metric, 0),
        }
}</span>

// Add adds a metric to the buffer
func (b *MetricBuffer) Add(m collector.Metric) <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.metrics = append(b.metrics, m)
}</span>

// Len returns the number of metrics in the buffer
func (b *MetricBuffer) Len() int <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return len(b.metrics)
}</span>

// GetValues returns all values for a specific resource/metric/labels key
func (b *MetricBuffer) GetValues(key ResourceMetricKey) []float64 <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        var values []float64
        for _, m := range b.metrics </span><span class="cov8" title="1">{
                if m.ResourceType == key.ResourceType &amp;&amp; m.Name == key.MetricName </span><span class="cov8" title="1">{
                        // Match labels (empty string matches empty/nil labels)
                        metricLabels := LabelsToString(m.Labels)
                        if metricLabels == key.Labels </span><span class="cov8" title="1">{
                                values = append(values, m.Value)
                        }</span>
                }
        }
        <span class="cov8" title="1">return values</span>
}

// GetResourceMetricKeys returns all unique (resourceType, metricName, labels) tuples
func (b *MetricBuffer) GetResourceMetricKeys() []ResourceMetricKey <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        seen := make(map[ResourceMetricKey]bool)
        var keys []ResourceMetricKey

        for _, m := range b.metrics </span><span class="cov8" title="1">{
                key := ResourceMetricKey{
                        ResourceType: m.ResourceType,
                        MetricName:   m.Name,
                        Labels:       LabelsToString(m.Labels),
                }
                if !seen[key] </span><span class="cov8" title="1">{
                        seen[key] = true
                        keys = append(keys, key)
                }</span>
        }
        <span class="cov8" title="1">return keys</span>
}

// ResourceMetricKey identifies a unique resource/metric/labels combination
type ResourceMetricKey struct {
        ResourceType string
        MetricName   string
        Labels       string // JSON-encoded map, sorted keys for determinism
}

// LabelsToString converts labels map to deterministic JSON string
func LabelsToString(labels map[string]string) string <span class="cov8" title="1">{
        if len(labels) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        // Sort keys for deterministic output
        <span class="cov8" title="1">keys := make([]string, 0, len(labels))
        for k := range labels </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        // Create ordered map for JSON
        orderedMap := make(map[string]string)
        for _, k := range keys </span><span class="cov8" title="1">{
                orderedMap[k] = labels[k]
        }</span>

        <span class="cov8" title="1">b, _ := json.Marshal(orderedMap)
        return string(b)</span>
}

// Clear removes all metrics from the buffer
func (b *MetricBuffer) Clear() <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.metrics = b.metrics[:0] // Reuse underlying array
}</span>

// WindowStart returns the start time of the current window
func (b *MetricBuffer) WindowStart() time.Time <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return b.windowStart
}</span>

// WindowEnd returns the end time of the current window
func (b *MetricBuffer) WindowEnd() time.Time <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return b.windowStart.Add(b.duration)
}</span>

// IsWindowComplete returns true if the window has ended
func (b *MetricBuffer) IsWindowComplete(now time.Time) bool <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return now.After(b.windowStart.Add(b.duration)) || now.Equal(b.windowStart.Add(b.duration))
}</span>

// ResetWindow resets the buffer for a new window
func (b *MetricBuffer) ResetWindow(now time.Time) <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.windowStart = now.Truncate(b.duration)
        b.metrics = b.metrics[:0]
}</span>

// Duration returns the window duration
func (b *MetricBuffer) Duration() time.Duration <span class="cov8" title="1">{
        return b.duration
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package collector

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// Metric represents a single collected metric
type Metric struct {
        ResourceType string            // cpu, memory, disk
        Name         string            // metric name (e.g., usage_percent)
        Value        float64           // metric value
        Timestamp    time.Time         // when the metric was collected
        Labels       map[string]string // optional labels (e.g., disk mount point)
}

// Collector interface for all metric collectors
type Collector interface {
        // Type returns the resource type (cpu, memory, disk)
        Type() string
        // Collect gathers metrics and returns them
        Collect(ctx context.Context) ([]Metric, error)
}

// Manager manages multiple collectors
type Manager struct {
        collectors []Collector
        interval   time.Duration
        mu         sync.RWMutex
}

// NewManager creates a new collector manager
func NewManager(interval time.Duration) *Manager <span class="cov8" title="1">{
        return &amp;Manager{
                collectors: make([]Collector, 0),
                interval:   interval,
        }
}</span>

// Register adds a collector to the manager
func (m *Manager) Register(c Collector) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.collectors = append(m.collectors, c)
}</span>

// Start begins collecting metrics at the configured interval
// It calls the handler function with collected metrics
func (m *Manager) Start(ctx context.Context, handler func([]Metric)) <span class="cov8" title="1">{
        ticker := time.NewTicker(m.interval)
        defer ticker.Stop()

        // Collect immediately on start
        metrics, err := m.CollectOnce(ctx)
        if err == nil &amp;&amp; len(metrics) &gt; 0 </span><span class="cov8" title="1">{
                handler(metrics)
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        metrics, err := m.CollectOnce(ctx)
                        if err != nil </span><span class="cov8" title="1">{
                                continue</span> // Log error in production
                        }
                        <span class="cov8" title="1">if len(metrics) &gt; 0 </span><span class="cov8" title="1">{
                                handler(metrics)
                        }</span>
                }
        }
}

// CollectOnce collects metrics from all collectors once
func (m *Manager) CollectOnce(ctx context.Context) ([]Metric, error) <span class="cov8" title="1">{
        m.mu.RLock()
        collectors := make([]Collector, len(m.collectors))
        copy(collectors, m.collectors)
        m.mu.RUnlock()

        var allMetrics []Metric
        var errs []error

        for _, c := range collectors </span><span class="cov8" title="1">{
                metrics, err := c.Collect(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("%s collector: %w", c.Type(), err))
                        continue</span>
                }
                <span class="cov8" title="1">allMetrics = append(allMetrics, metrics...)</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 &amp;&amp; len(allMetrics) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("all collectors failed: %v", errs)
        }</span>

        <span class="cov8" title="1">return allMetrics, nil</span>
}

// Pseudo-filesystem types to filter out for disk collector
var pseudoFSTypes = map[string]bool{
        "tmpfs":      true,
        "devtmpfs":   true,
        "sysfs":      true,
        "proc":       true,
        "overlay":    true,
        "squashfs":   true,
        "aufs":       true,
        "debugfs":    true,
        "cgroup":     true,
        "cgroup2":    true,
        "pstore":     true,
        "bpf":        true,
        "tracefs":    true,
        "hugetlbfs":  true,
        "mqueue":     true,
        "fusectl":    true,
        "configfs":   true,
        "efivarfs":   true,
        "nsfs":       true,
        "devpts":     true,
        "securityfs": true,
        "autofs":     true,
}

// isPseudoFS checks if a filesystem type is a pseudo-filesystem
func isPseudoFS(fstype string) bool <span class="cov8" title="1">{
        return pseudoFSTypes[fstype]
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package collector

import (
        "context"
        "time"

        "github.com/shirou/gopsutil/v3/cpu"
)

// CPUCollector collects CPU metrics
type CPUCollector struct {
        // Use 200ms measurement interval for accurate readings
        measurementInterval time.Duration
}

// NewCPUCollector creates a new CPU collector
func NewCPUCollector() *CPUCollector <span class="cov8" title="1">{
        return &amp;CPUCollector{
                measurementInterval: 200 * time.Millisecond,
        }
}</span>

// Type returns the resource type
func (c *CPUCollector) Type() string <span class="cov8" title="1">{
        return "cpu"
}</span>

// Collect gathers CPU metrics
func (c *CPUCollector) Collect(ctx context.Context) ([]Metric, error) <span class="cov8" title="1">{
        // Get CPU usage percentage (use interval &gt; 0 for accurate readings)
        percentages, err := cpu.PercentWithContext(ctx, c.measurementInterval, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">now := time.Now()
        metrics := make([]Metric, 0, len(percentages)+1)

        // Overall CPU usage (average across all cores)
        if len(percentages) &gt; 0 </span><span class="cov8" title="1">{
                var total float64
                for _, p := range percentages </span><span class="cov8" title="1">{
                        total += p
                }</span>
                <span class="cov8" title="1">avg := total / float64(len(percentages))

                metrics = append(metrics, Metric{
                        ResourceType: "cpu",
                        Name:         "usage_percent",
                        Value:        avg,
                        Timestamp:    now,
                })</span>
        }

        <span class="cov8" title="1">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package collector

import (
        "context"
        "log"
        "time"

        "github.com/shirou/gopsutil/v3/disk"

        "github.com/etlmon/etlmon/internal/config"
)

// DiskCollector collects disk metrics
type DiskCollector struct {
        config     config.DiskConfig
        collectors map[config.DiskMethod]DiskMethodCollector
}

// NewDiskCollector creates a disk collector with auto-discover behavior (backward compatible)
func NewDiskCollector() *DiskCollector <span class="cov8" title="1">{
        return NewDiskCollectorWithConfig(config.DiskConfig{})
}</span>

// NewDiskCollectorWithConfig creates a disk collector with explicit configuration
func NewDiskCollectorWithConfig(cfg config.DiskConfig) *DiskCollector <span class="cov8" title="1">{
        collectors := map[config.DiskMethod]DiskMethodCollector{
                config.DiskMethodStats: NewStatsCollector(),
                config.DiskMethodDF:    NewDFCollector(),
                config.DiskMethodDU:    NewDUCollector(),
        }

        return &amp;DiskCollector{
                config:     cfg,
                collectors: collectors,
        }
}</span>

// Type returns the resource type
func (c *DiskCollector) Type() string <span class="cov8" title="1">{
        return "disk"
}</span>

// Collect gathers disk metrics
func (c *DiskCollector) Collect(ctx context.Context) ([]Metric, error) <span class="cov8" title="1">{
        // If no paths configured, use auto-discover (backward compatible)
        if len(c.config.Paths) == 0 </span><span class="cov8" title="1">{
                return c.collectAutoDiscover(ctx)
        }</span>

        <span class="cov8" title="1">return c.collectConfiguredPaths(ctx)</span>
}

// collectAutoDiscover collects from all discovered partitions (original behavior)
func (c *DiskCollector) collectAutoDiscover(ctx context.Context) ([]Metric, error) <span class="cov8" title="1">{
        partitions, err := disk.PartitionsWithContext(ctx, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">now := time.Now()
        var metrics []Metric

        for _, p := range partitions </span><span class="cov8" title="1">{
                // Filter out pseudo-filesystems
                if isPseudoFS(p.Fstype) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">usage, err := disk.UsageWithContext(ctx, p.Mountpoint)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to get usage for %s: %v", p.Mountpoint, err)
                        continue</span> // Skip partitions we can't read
                }

                // Use mount point as label
                <span class="cov8" title="1">labels := map[string]string{
                        "mountpoint": p.Mountpoint,
                        "device":     p.Device,
                        "fstype":     p.Fstype,
                        "method":     "stats", // Auto-discover always uses stats
                }

                metrics = append(metrics, Metric{
                        ResourceType: "disk",
                        Name:         "usage_percent",
                        Value:        usage.UsedPercent,
                        Timestamp:    now,
                        Labels:       labels,
                })

                metrics = append(metrics, Metric{
                        ResourceType: "disk",
                        Name:         "used_bytes",
                        Value:        float64(usage.Used),
                        Timestamp:    now,
                        Labels:       labels,
                })

                metrics = append(metrics, Metric{
                        ResourceType: "disk",
                        Name:         "total_bytes",
                        Value:        float64(usage.Total),
                        Timestamp:    now,
                        Labels:       labels,
                })</span>
        }

        <span class="cov8" title="1">return metrics, nil</span>
}

// collectConfiguredPaths collects from configured paths only
func (c *DiskCollector) collectConfiguredPaths(ctx context.Context) ([]Metric, error) <span class="cov8" title="1">{
        now := time.Now()
        var metrics []Metric

        for _, pathCfg := range c.config.Paths </span><span class="cov8" title="1">{
                method := c.config.GetMethod(pathCfg)
                collector, ok := c.collectors[method]
                if !ok </span><span class="cov0" title="0">{
                        log.Printf("Warning: unknown method %s for path %s, using stats", method, pathCfg.Path)
                        collector = c.collectors[config.DiskMethodStats]
                }</span>

                <span class="cov8" title="1">usage, err := collector.Collect(ctx, pathCfg.Path)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: failed to collect disk metrics for %s (method=%s): %v", pathCfg.Path, method, err)
                        continue</span> // Skip paths that fail, continue with others
                }

                // Build labels
                <span class="cov8" title="1">labels := map[string]string{
                        "path":       pathCfg.Path,
                        "mountpoint": usage.Path,
                        "method":     string(method),
                }
                if usage.Device != "" </span><span class="cov8" title="1">{
                        labels["device"] = usage.Device
                }</span>
                <span class="cov8" title="1">if usage.FSType != "" </span><span class="cov8" title="1">{
                        labels["fstype"] = usage.FSType
                }</span>

                // Always add used_bytes (available for all methods)
                <span class="cov8" title="1">metrics = append(metrics, Metric{
                        ResourceType: "disk",
                        Name:         "used_bytes",
                        Value:        float64(usage.Used),
                        Timestamp:    now,
                        Labels:       labels,
                })

                // Only add total_bytes and usage_percent if we have total (not available for du)
                if usage.Total &gt; 0 </span><span class="cov8" title="1">{
                        metrics = append(metrics, Metric{
                                ResourceType: "disk",
                                Name:         "total_bytes",
                                Value:        float64(usage.Total),
                                Timestamp:    now,
                                Labels:       labels,
                        })

                        metrics = append(metrics, Metric{
                                ResourceType: "disk",
                                Name:         "usage_percent",
                                Value:        usage.UsedPercent,
                                Timestamp:    now,
                                Labels:       labels,
                        })
                }</span>

                // Add free_bytes if available
                <span class="cov8" title="1">if usage.Free &gt; 0 </span><span class="cov8" title="1">{
                        metrics = append(metrics, Metric{
                                ResourceType: "disk",
                                Name:         "free_bytes",
                                Value:        float64(usage.Free),
                                Timestamp:    now,
                                Labels:       labels,
                        })
                }</span>
        }

        <span class="cov8" title="1">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package collector

import (
        "bufio"
        "context"
        "fmt"
        "os/exec"
        "runtime"
        "strconv"
        "strings"
        "time"

        "github.com/shirou/gopsutil/v3/disk"
)

// CommandTimeout is the default timeout for external commands
const CommandTimeout = 30 * time.Second

// DiskUsage holds disk usage information for a path
type DiskUsage struct {
        Path        string
        Total       uint64
        Used        uint64
        Free        uint64
        UsedPercent float64
        Device      string
        FSType      string
}

// DiskMethodCollector is the interface for disk collection methods
type DiskMethodCollector interface {
        Collect(ctx context.Context, path string) (*DiskUsage, error)
        Name() string
}

// StatsCollector uses gopsutil (syscall.Statfs) to collect disk metrics
type StatsCollector struct{}

// NewStatsCollector creates a new stats collector
func NewStatsCollector() *StatsCollector <span class="cov8" title="1">{
        return &amp;StatsCollector{}
}</span>

// Name returns the collector name
func (c *StatsCollector) Name() string <span class="cov8" title="1">{
        return "stats"
}</span>

// Collect gathers disk usage using gopsutil
func (c *StatsCollector) Collect(ctx context.Context, path string) (*DiskUsage, error) <span class="cov8" title="1">{
        usage, err := disk.UsageWithContext(ctx, path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("stats collection failed for %s: %w", path, err)
        }</span>

        // Get partition info for device and fstype
        <span class="cov8" title="1">partitions, _ := disk.PartitionsWithContext(ctx, false)
        var device, fstype string
        for _, p := range partitions </span><span class="cov8" title="1">{
                if p.Mountpoint == path </span><span class="cov8" title="1">{
                        device = p.Device
                        fstype = p.Fstype
                        break</span>
                }
        }

        <span class="cov8" title="1">return &amp;DiskUsage{
                Path:        path,
                Total:       usage.Total,
                Used:        usage.Used,
                Free:        usage.Free,
                UsedPercent: usage.UsedPercent,
                Device:      device,
                FSType:      fstype,
        }, nil</span>
}

// DFCollector uses the df command to collect disk metrics
type DFCollector struct{}

// NewDFCollector creates a new df collector
func NewDFCollector() *DFCollector <span class="cov8" title="1">{
        return &amp;DFCollector{}
}</span>

// Name returns the collector name
func (c *DFCollector) Name() string <span class="cov8" title="1">{
        return "df"
}</span>

// Collect gathers disk usage using the df command
func (c *DFCollector) Collect(ctx context.Context, path string) (*DiskUsage, error) <span class="cov8" title="1">{
        // Create context with timeout
        ctx, cancel := context.WithTimeout(ctx, CommandTimeout)
        defer cancel()

        var cmd *exec.Cmd
        var blockMultiplier uint64 = 1

        if runtime.GOOS == "darwin" </span><span class="cov8" title="1">{
                // macOS: df -b returns 512-byte blocks
                cmd = exec.CommandContext(ctx, "df", "-b", path)
                blockMultiplier = 512
        }</span> else<span class="cov0" title="0"> {
                // Linux: df -B1 returns bytes directly
                cmd = exec.CommandContext(ctx, "df", "-B1", path)
        }</span>

        <span class="cov8" title="1">output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("df command failed for %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return parseDFOutput(string(output), path, blockMultiplier)</span>
}

// parseDFOutput parses df command output
func parseDFOutput(output, path string, blockMultiplier uint64) (*DiskUsage, error) <span class="cov8" title="1">{
        scanner := bufio.NewScanner(strings.NewReader(output))

        // Skip header line
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty df output")
        }</span>

        // Parse data line
        <span class="cov8" title="1">if !scanner.Scan() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no data in df output")
        }</span>

        <span class="cov8" title="1">line := scanner.Text()
        fields := strings.Fields(line)

        // df output format: Filesystem Blocks Used Available Capacity Mounted
        // Minimum 6 fields expected
        if len(fields) &lt; 6 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected df output format: %s", line)
        }</span>

        <span class="cov8" title="1">device := fields[0]

        total, err := strconv.ParseUint(fields[1], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing total blocks: %w", err)
        }</span>
        <span class="cov8" title="1">total *= blockMultiplier

        used, err := strconv.ParseUint(fields[2], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing used blocks: %w", err)
        }</span>
        <span class="cov8" title="1">used *= blockMultiplier

        free, err := strconv.ParseUint(fields[3], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing free blocks: %w", err)
        }</span>
        <span class="cov8" title="1">free *= blockMultiplier

        var usedPercent float64
        if total &gt; 0 </span><span class="cov8" title="1">{
                usedPercent = float64(used) / float64(total) * 100
        }</span>

        <span class="cov8" title="1">return &amp;DiskUsage{
                Path:        path,
                Total:       total,
                Used:        used,
                Free:        free,
                UsedPercent: usedPercent,
                Device:      device,
                FSType:      "", // df doesn't provide fstype
        }, nil</span>
}

// DUCollector uses the du command to collect disk metrics
type DUCollector struct{}

// NewDUCollector creates a new du collector
func NewDUCollector() *DUCollector <span class="cov8" title="1">{
        return &amp;DUCollector{}
}</span>

// Name returns the collector name
func (c *DUCollector) Name() string <span class="cov8" title="1">{
        return "du"
}</span>

// Collect gathers disk usage using the du command (recursive)
func (c *DUCollector) Collect(ctx context.Context, path string) (*DiskUsage, error) <span class="cov8" title="1">{
        // Create context with timeout
        ctx, cancel := context.WithTimeout(ctx, CommandTimeout)
        defer cancel()

        // du -sb: summarize, bytes (works on both Linux and macOS with coreutils)
        // On macOS without coreutils, fall back to du -s and multiply by 512
        var cmd *exec.Cmd
        var blockMultiplier uint64 = 1

        if runtime.GOOS == "darwin" </span><span class="cov8" title="1">{
                // Try du -s first (512-byte blocks on macOS)
                cmd = exec.CommandContext(ctx, "du", "-s", path)
                blockMultiplier = 512
        }</span> else<span class="cov0" title="0"> {
                // Linux: du -sb for bytes
                cmd = exec.CommandContext(ctx, "du", "-sb", path)
        }</span>

        <span class="cov8" title="1">output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("du command failed for %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return parseDUOutput(string(output), path, blockMultiplier)</span>
}

// parseDUOutput parses du command output
func parseDUOutput(output, path string, blockMultiplier uint64) (*DiskUsage, error) <span class="cov8" title="1">{
        output = strings.TrimSpace(output)
        if output == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty du output")
        }</span>

        // du output format: SIZE\tPATH
        <span class="cov8" title="1">fields := strings.Fields(output)
        if len(fields) &lt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected du output format: %s", output)
        }</span>

        <span class="cov8" title="1">used, err := strconv.ParseUint(fields[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing du size: %w", err)
        }</span>
        <span class="cov8" title="1">used *= blockMultiplier

        // du only gives us used space, not total
        // For du method, we can't calculate percentage without knowing total
        return &amp;DiskUsage{
                Path:        path,
                Total:       0, // Unknown for du
                Used:        used,
                Free:        0, // Unknown for du
                UsedPercent: 0, // Cannot calculate without total
                Device:      "",
                FSType:      "",
        }, nil</span>
}

// GetMethodCollector returns the appropriate collector for a method
func GetMethodCollector(method string) DiskMethodCollector <span class="cov8" title="1">{
        switch method </span>{
        case "df":<span class="cov8" title="1">
                return NewDFCollector()</span>
        case "du":<span class="cov8" title="1">
                return NewDUCollector()</span>
        default:<span class="cov8" title="1">
                return NewStatsCollector()</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package collector

import (
        "context"
        "time"

        "github.com/shirou/gopsutil/v3/mem"
)

// MemoryCollector collects memory metrics
type MemoryCollector struct{}

// NewMemoryCollector creates a new memory collector
func NewMemoryCollector() *MemoryCollector <span class="cov8" title="1">{
        return &amp;MemoryCollector{}
}</span>

// Type returns the resource type
func (c *MemoryCollector) Type() string <span class="cov8" title="1">{
        return "memory"
}</span>

// Collect gathers memory metrics
func (c *MemoryCollector) Collect(ctx context.Context) ([]Metric, error) <span class="cov8" title="1">{
        v, err := mem.VirtualMemoryWithContext(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">now := time.Now()

        metrics := []Metric{
                {
                        ResourceType: "memory",
                        Name:         "usage_percent",
                        Value:        v.UsedPercent,
                        Timestamp:    now,
                },
                {
                        ResourceType: "memory",
                        Name:         "used_bytes",
                        Value:        float64(v.Used),
                        Timestamp:    now,
                },
                {
                        ResourceType: "memory",
                        Name:         "available_bytes",
                        Value:        float64(v.Available),
                        Timestamp:    now,
                },
                {
                        ResourceType: "memory",
                        Name:         "total_bytes",
                        Value:        float64(v.Total),
                        Timestamp:    now,
                },
        }

        return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "fmt"
        "os"
        "time"

        "gopkg.in/yaml.v3"
)

// Config holds all configuration for etlmon
type Config struct {
        Interval     time.Duration  `yaml:"-"` // Parsed from IntervalStr
        IntervalStr  string         `yaml:"interval"`
        Resources    []string       `yaml:"resources"`
        Windows      []string       `yaml:"windows"`
        Aggregations []string       `yaml:"aggregations"`
        Database     DatabaseConfig `yaml:"database"`
        Disk         DiskConfig     `yaml:"disk,omitempty"`
}

// DatabaseConfig holds database configuration
type DatabaseConfig struct {
        Path string `yaml:"path"`
}

// DiskMethod represents the collection method for disk metrics
type DiskMethod string

const (
        DiskMethodStats DiskMethod = "stats" // gopsutil/syscall.Statfs (default)
        DiskMethodDF    DiskMethod = "df"    // parse df command output
        DiskMethodDU    DiskMethod = "du"    // run du command (recursive)
)

// DiskPathConfig configures collection for a specific path
type DiskPathConfig struct {
        Path   string     `yaml:"path"`             // filesystem path or mountpoint
        Method DiskMethod `yaml:"method,omitempty"` // collection method (uses default if empty)
}

// DiskConfig holds disk-specific configuration
type DiskConfig struct {
        DefaultMethod DiskMethod       `yaml:"default_method,omitempty"` // default: stats
        Paths         []DiskPathConfig `yaml:"paths,omitempty"`          // if empty, auto-discover
}

// Valid resources, windows, and aggregations
var (
        ValidResources = map[string]bool{
                "cpu":    true,
                "memory": true,
                "disk":   true,
        }

        ValidAggregations = map[string]bool{
                "avg":  true,
                "max":  true,
                "min":  true,
                "last": true,
        }

        ValidDiskMethods = map[DiskMethod]bool{
                DiskMethodStats: true,
                DiskMethodDF:    true,
                DiskMethodDU:    true,
        }
)

// Load reads and parses a configuration file
func Load(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("reading config file: %w", err)
        }</span>
        
        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parsing config YAML: %w", err)
        }</span>
        
        // Parse interval string to duration
        <span class="cov8" title="1">if cfg.IntervalStr != "" </span><span class="cov8" title="1">{
                interval, err := time.ParseDuration(cfg.IntervalStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parsing interval %q: %w", cfg.IntervalStr, err)
                }</span>
                <span class="cov8" title="1">cfg.Interval = interval</span>
        }
        
        // Set default database path if not specified
        <span class="cov8" title="1">if cfg.Database.Path == "" </span><span class="cov0" title="0">{
                cfg.Database.Path = "./etlmon.db"
        }</span>
        
        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.Interval &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("interval must be positive")
        }</span>
        
        <span class="cov8" title="1">if len(c.Resources) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one resource must be specified")
        }</span>
        
        <span class="cov8" title="1">for _, r := range c.Resources </span><span class="cov8" title="1">{
                if !ValidResources[r] </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid resource: %s (valid: cpu, memory, disk)", r)
                }</span>
        }
        
        <span class="cov8" title="1">if len(c.Windows) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one window must be specified")
        }</span>
        
        <span class="cov8" title="1">for _, w := range c.Windows </span><span class="cov8" title="1">{
                if _, err := ParseWindow(w); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid window %q: %w", w, err)
                }</span>
        }
        
        <span class="cov8" title="1">if len(c.Aggregations) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one aggregation must be specified")
        }</span>
        
        <span class="cov8" title="1">for _, a := range c.Aggregations </span><span class="cov8" title="1">{
                if !ValidAggregations[a] </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid aggregation: %s (valid: avg, max, min, last)", a)
                }</span>
        }

        // Validate disk configuration
        <span class="cov8" title="1">if err := c.Disk.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid disk config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ParseWindow parses a window string like "1m", "5m", "1h" into a duration
func ParseWindow(s string) (time.Duration, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("empty window string")
        }</span>
        
        <span class="cov8" title="1">d, err := time.ParseDuration(s)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid window format: %w", err)
        }</span>
        
        <span class="cov8" title="1">if d &lt;= 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("window must be positive")
        }</span>
        
        <span class="cov8" title="1">return d, nil</span>
}

// GetWindowDurations returns all windows as time.Duration
func (c *Config) GetWindowDurations() ([]time.Duration, error) <span class="cov8" title="1">{
        durations := make([]time.Duration, len(c.Windows))
        for i, w := range c.Windows </span><span class="cov8" title="1">{
                d, err := ParseWindow(w)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">durations[i] = d</span>
        }
        <span class="cov8" title="1">return durations, nil</span>
}

// Validate validates the disk configuration
func (d *DiskConfig) Validate() error <span class="cov8" title="1">{
        // Validate default method if specified
        if d.DefaultMethod != "" &amp;&amp; !ValidDiskMethods[d.DefaultMethod] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid default_method: %s (valid: stats, df, du)", d.DefaultMethod)
        }</span>

        // Validate each path configuration
        <span class="cov8" title="1">for i, p := range d.Paths </span><span class="cov0" title="0">{
                if p.Path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("path %d: path cannot be empty", i)
                }</span>
                <span class="cov0" title="0">if p.Method != "" &amp;&amp; !ValidDiskMethods[p.Method] </span><span class="cov0" title="0">{
                        return fmt.Errorf("path %d (%s): invalid method %s (valid: stats, df, du)", i, p.Path, p.Method)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetMethod returns the effective method for a path, using default if not specified
func (d *DiskConfig) GetMethod(pathConfig DiskPathConfig) DiskMethod <span class="cov0" title="0">{
        if pathConfig.Method != "" </span><span class="cov0" title="0">{
                return pathConfig.Method
        }</span>
        <span class="cov0" title="0">if d.DefaultMethod != "" </span><span class="cov0" title="0">{
                return d.DefaultMethod
        }</span>
        <span class="cov0" title="0">return DiskMethodStats</span> // Default to stats
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package storage

import (
        "database/sql"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "sync"

        _ "modernc.org/sqlite"
)

// SQLiteStore implements storage using SQLite
type SQLiteStore struct {
        db     *sql.DB
        path   string
        mu     sync.Mutex
        closed bool
}

// NewSQLiteStore creates a new SQLite store
func NewSQLiteStore(dbPath string) (*SQLiteStore, error) <span class="cov8" title="1">{
        // Ensure directory exists
        dir := filepath.Dir(dbPath)
        if dir != "." &amp;&amp; dir != "" </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("creating database directory: %w", err)
                }</span>
        }

        // Open database with WAL mode for better concurrency
        <span class="cov8" title="1">dsn := fmt.Sprintf("%s?_journal_mode=WAL&amp;_busy_timeout=5000", dbPath)
        db, err := sql.Open("sqlite", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("opening database: %w", err)
        }</span>

        // Test connection
        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("connecting to database: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;SQLiteStore{
                db:   db,
                path: dbPath,
        }, nil</span>
}

// Initialize creates the database schema
func (s *SQLiteStore) Initialize() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        _, err := s.db.Exec(createTableSQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating schema: %w", err)
        }</span>

        // Migration: Add labels column if it doesn't exist
        <span class="cov8" title="1">var count int
        row := s.db.QueryRow(`SELECT COUNT(*) FROM pragma_table_info('aggregated_metrics') WHERE name='labels'`)
        if err := row.Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("checking for labels column: %w", err)
        }</span>

        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                _, err = s.db.Exec(`ALTER TABLE aggregated_metrics ADD COLUMN labels TEXT DEFAULT ''`)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrating schema (adding labels): %w", err)
                }</span>
                <span class="cov8" title="1">_, err = s.db.Exec(`CREATE INDEX IF NOT EXISTS idx_metrics_labels ON aggregated_metrics(labels)`)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("creating labels index: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SaveAggregatedMetric saves a single aggregated metric
func (s *SQLiteStore) SaveAggregatedMetric(metric *AggregatedMetric) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        _, err := s.db.Exec(`
        INSERT INTO aggregated_metrics (timestamp, resource_type, metric_name, aggregated_value, window_size, aggregation_type, labels)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `, metric.Timestamp, metric.ResourceType, metric.MetricName, metric.AggregatedValue, metric.WindowSize, metric.AggregationType, metric.Labels)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("inserting metric: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SaveBatch saves multiple metrics in a transaction
func (s *SQLiteStore) SaveBatch(metrics []*AggregatedMetric) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        tx, err := s.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("beginning transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        stmt, err := tx.Prepare(`
        INSERT INTO aggregated_metrics (timestamp, resource_type, metric_name, aggregated_value, window_size, aggregation_type, labels)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("preparing statement: %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()

        for _, metric := range metrics </span><span class="cov8" title="1">{
                _, err := stmt.Exec(metric.Timestamp, metric.ResourceType, metric.MetricName, metric.AggregatedValue, metric.WindowSize, metric.AggregationType, metric.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("inserting metric: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("committing transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetMetrics retrieves metrics with optional filtering
func (s *SQLiteStore) GetMetrics(opts GetMetricsOptions) ([]*AggregatedMetric, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        var conditions []string
        var args []interface{}

        if opts.ResourceType != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "resource_type = ?")
                args = append(args, opts.ResourceType)
        }</span>
        <span class="cov8" title="1">if opts.MetricName != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "metric_name = ?")
                args = append(args, opts.MetricName)
        }</span>
        <span class="cov8" title="1">if opts.WindowSize != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "window_size = ?")
                args = append(args, opts.WindowSize)
        }</span>
        <span class="cov8" title="1">if opts.AggregationType != "" </span><span class="cov8" title="1">{
                conditions = append(conditions, "aggregation_type = ?")
                args = append(args, opts.AggregationType)
        }</span>
        <span class="cov8" title="1">if opts.StartTime &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, "timestamp &gt;= ?")
                args = append(args, opts.StartTime)
        }</span>
        <span class="cov8" title="1">if opts.EndTime &gt; 0 </span><span class="cov0" title="0">{
                conditions = append(conditions, "timestamp &lt;= ?")
                args = append(args, opts.EndTime)
        }</span>
        <span class="cov8" title="1">if opts.Labels != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "labels = ?")
                args = append(args, opts.Labels)
        }</span>

        <span class="cov8" title="1">query := "SELECT id, timestamp, resource_type, metric_name, aggregated_value, window_size, aggregation_type, COALESCE(labels, '') FROM aggregated_metrics"
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                query += " WHERE " + strings.Join(conditions, " AND ")
        }</span>
        <span class="cov8" title="1">query += " ORDER BY timestamp DESC"

        if opts.Limit &gt; 0 </span><span class="cov8" title="1">{
                query += fmt.Sprintf(" LIMIT %d", opts.Limit)
        }</span>

        <span class="cov8" title="1">rows, err := s.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("querying metrics: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var metrics []*AggregatedMetric
        for rows.Next() </span><span class="cov8" title="1">{
                m := &amp;AggregatedMetric{}
                err := rows.Scan(&amp;m.ID, &amp;m.Timestamp, &amp;m.ResourceType, &amp;m.MetricName, &amp;m.AggregatedValue, &amp;m.WindowSize, &amp;m.AggregationType, &amp;m.Labels)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scanning row: %w", err)
                }</span>
                <span class="cov8" title="1">metrics = append(metrics, m)</span>
        }

        <span class="cov8" title="1">return metrics, nil</span>
}

// GetLatestMetrics gets the most recent metrics for a resource type and window
func (s *SQLiteStore) GetLatestMetrics(resourceType, windowSize string) ([]*AggregatedMetric, error) <span class="cov8" title="1">{
        return s.GetMetrics(GetMetricsOptions{
                ResourceType: resourceType,
                WindowSize:   windowSize,
                Limit:        10,
        })
}</span>

// Close closes the database connection
func (s *SQLiteStore) Close() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">s.closed = true

        return s.db.Close()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package tui

import (
        "fmt"
        "sync"
        "time"

        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"

        "github.com/etlmon/etlmon/internal/aggregator"
        "github.com/etlmon/etlmon/internal/collector"
        "github.com/etlmon/etlmon/internal/storage"
)

// ViewMode represents the current view mode
type ViewMode int

const (
        ViewRealtime ViewMode = iota
        ViewHistory
)

// Store interface for database operations
type Store interface {
        GetMetrics(opts storage.GetMetricsOptions) ([]*storage.AggregatedMetric, error)
        GetLatestMetrics(resourceType, windowSize string) ([]*storage.AggregatedMetric, error)
}

// App is the main TUI application
type App struct {
        app          *tview.Application
        pages        *tview.Pages
        realtimeView *RealtimeView
        historyView  *HistoryView
        statusBar    *StatusBar
        currentView  ViewMode
        store        Store
        running      bool
        mu           sync.RWMutex
}

// NewApp creates a new TUI application
func NewApp() *App <span class="cov8" title="1">{
        a := &amp;App{
                app:          tview.NewApplication(),
                pages:        tview.NewPages(),
                realtimeView: NewRealtimeView(),
                historyView:  NewHistoryView(),
                statusBar:    NewStatusBar(),
                currentView:  ViewRealtime,
        }

        a.setupLayout()
        a.setupKeybindings()

        return a
}</span>

// setupLayout creates the UI layout
func (a *App) setupLayout() <span class="cov8" title="1">{
        // Main layout with status bar at bottom
        mainFlex := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(a.pages, 0, 1, true).
                AddItem(a.statusBar.view, 1, 0, false)

        // Add views to pages
        a.pages.AddPage("realtime", a.realtimeView.view, true, true)
        a.pages.AddPage("history", a.historyView.view, true, false)

        a.app.SetRoot(mainFlex, true)
}</span>

// setupKeybindings configures keyboard shortcuts
func (a *App) setupKeybindings() <span class="cov8" title="1">{
        a.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                switch event.Key() </span>{
                case tcell.KeyEscape, tcell.KeyCtrlC:<span class="cov0" title="0">
                        a.app.Stop()
                        return nil</span>
                case tcell.KeyTab:<span class="cov0" title="0">
                        a.toggleView()
                        return nil</span>
                }

                <span class="cov0" title="0">switch event.Rune() </span>{
                case 'q', 'Q':<span class="cov0" title="0">
                        a.app.Stop()
                        return nil</span>
                case 'r', 'R':<span class="cov0" title="0">
                        a.SwitchView(ViewRealtime)
                        return nil</span>
                case 'h', 'H':<span class="cov0" title="0">
                        a.SwitchView(ViewHistory)
                        return nil</span>
                case '1':<span class="cov0" title="0">
                        a.historyView.SetWindowFilter("1m")
                        a.refreshHistory()
                        return nil</span>
                case '5':<span class="cov0" title="0">
                        a.historyView.SetWindowFilter("5m")
                        a.refreshHistory()
                        return nil</span>
                case '0':<span class="cov0" title="0">
                        a.historyView.SetWindowFilter("1h")
                        a.refreshHistory()
                        return nil</span>
                case 't', 'T':<span class="cov0" title="0">
                        a.mu.RLock()
                        currentView := a.currentView
                        a.mu.RUnlock()
                        if currentView == ViewRealtime </span><span class="cov0" title="0">{
                                a.realtimeView.ToggleDisplayFormat()
                                a.app.Draw()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">return event</span>
        })
}

// toggleView switches between realtime and history views
func (a *App) toggleView() <span class="cov0" title="0">{
        if a.currentView == ViewRealtime </span><span class="cov0" title="0">{
                a.SwitchView(ViewHistory)
        }</span> else<span class="cov0" title="0"> {
                a.SwitchView(ViewRealtime)
        }</span>
}

// SwitchView changes the current view
func (a *App) SwitchView(mode ViewMode) <span class="cov8" title="1">{
        a.mu.Lock()
        a.currentView = mode
        a.mu.Unlock()

        switch mode </span>{
        case ViewRealtime:<span class="cov8" title="1">
                a.pages.SwitchToPage("realtime")</span>
        case ViewHistory:<span class="cov8" title="1">
                a.pages.SwitchToPage("history")
                a.refreshHistory()</span>
        }
}

// refreshHistory loads and displays history data
func (a *App) refreshHistory() <span class="cov8" title="1">{
        if a.store == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">a.mu.RLock()
        filter := a.historyView.windowFilter
        a.mu.RUnlock()

        metrics, err := a.store.GetMetrics(storage.GetMetricsOptions{
                WindowSize: filter,
                Limit:      100,
        })
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert to AggregationResult for display
        <span class="cov0" title="0">var results []aggregator.AggregationResult
        for _, m := range metrics </span><span class="cov0" title="0">{
                windowSize, _ := time.ParseDuration(m.WindowSize)
                results = append(results, aggregator.AggregationResult{
                        ResourceType:    m.ResourceType,
                        MetricName:      m.MetricName,
                        Value:           m.AggregatedValue,
                        WindowSize:      windowSize,
                        AggregationType: m.AggregationType,
                        Timestamp:       time.Unix(m.Timestamp, 0),
                })
        }</span>

        <span class="cov0" title="0">a.historyView.Update(results)</span>
}

// SetStore sets the storage backend
func (a *App) SetStore(store Store) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        a.store = store
}</span>

// OnMetricsCollected is called when new metrics are collected
func (a *App) OnMetricsCollected(metrics []collector.Metric) <span class="cov8" title="1">{
        a.realtimeView.Update(metrics)
        a.statusBar.SetLastUpdate(time.Now())
        // Only draw if the app is running
        a.mu.RLock()
        running := a.running
        a.mu.RUnlock()
        if running </span><span class="cov0" title="0">{
                a.app.Draw()
        }</span>
}

// OnAggregationComplete is called when aggregation results are ready
func (a *App) OnAggregationComplete(results []aggregator.AggregationResult) <span class="cov8" title="1">{
        // Add to history view
        a.historyView.Update(results)
        // Only draw if the app is running
        a.mu.RLock()
        running := a.running
        a.mu.RUnlock()
        if running </span><span class="cov0" title="0">{
                a.app.Draw()
        }</span>
}

// Run starts the TUI application
func (a *App) Run() error <span class="cov0" title="0">{
        a.mu.Lock()
        a.running = true
        a.mu.Unlock()
        a.statusBar.SetStatus("Running")
        err := a.app.Run()
        a.mu.Lock()
        a.running = false
        a.mu.Unlock()
        return err
}</span>

// Stop stops the TUI application
func (a *App) Stop() <span class="cov0" title="0">{
        a.app.Stop()
}</span>

// QueueUpdateDraw queues a UI update
func (a *App) QueueUpdateDraw(f func()) <span class="cov0" title="0">{
        a.app.QueueUpdateDraw(f)
}</span>

// FormatBytes formats bytes to human readable string
func FormatBytes(bytes float64) string <span class="cov8" title="1">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.0f B", bytes)
        }</span>
        <span class="cov8" title="1">div, exp := float64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", bytes/div, "KMGTPE"[exp])</span>
}

// FormatDuration formats duration to short string
func FormatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &gt;= time.Hour </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh", int(d.Hours()))
        }</span>
        <span class="cov8" title="1">if d &gt;= time.Minute </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", int(d.Minutes()))
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%ds", int(d.Seconds()))</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package tui

import (
        "fmt"
        "sort"
        "strings"
        "sync"

        "github.com/rivo/tview"

        "github.com/etlmon/etlmon/internal/aggregator"
)

// HistoryView displays aggregated historical metrics
type HistoryView struct {
        view           *tview.TextView
        results        []aggregator.AggregationResult
        windowFilter   string
        resourceFilter string
        mu             sync.RWMutex
}

// NewHistoryView creates a new history view
func NewHistoryView() *HistoryView <span class="cov8" title="1">{
        view := tview.NewTextView().
                SetDynamicColors(true).
                SetScrollable(true).
                SetWrap(false)

        view.SetBorder(true).
                SetTitle(" Aggregated History (1/5/0 for window, Tab to switch, Q to quit) ").
                SetTitleAlign(tview.AlignLeft)

        return &amp;HistoryView{
                view:         view,
                results:      make([]aggregator.AggregationResult, 0),
                windowFilter: "1m",
        }
}</span>

// Update updates the view with new aggregation results
func (v *HistoryView) Update(results []aggregator.AggregationResult) <span class="cov8" title="1">{
        v.mu.Lock()
        // Append new results
        v.results = append(v.results, results...)

        // Keep only last 1000 results
        if len(v.results) &gt; 1000 </span><span class="cov0" title="0">{
                v.results = v.results[len(v.results)-1000:]
        }</span>
        <span class="cov8" title="1">v.mu.Unlock()

        v.render()</span>
}

// SetWindowFilter sets the window size filter
func (v *HistoryView) SetWindowFilter(filter string) <span class="cov8" title="1">{
        v.mu.Lock()
        v.windowFilter = filter
        v.mu.Unlock()
        v.render()
}</span>

// SetResourceFilter sets the resource type filter
func (v *HistoryView) SetResourceFilter(filter string) <span class="cov8" title="1">{
        v.mu.Lock()
        v.resourceFilter = filter
        v.mu.Unlock()
        v.render()
}</span>

// render updates the text content
func (v *HistoryView) render() <span class="cov8" title="1">{
        v.mu.RLock()
        results := make([]aggregator.AggregationResult, len(v.results))
        copy(results, v.results)
        windowFilter := v.windowFilter
        resourceFilter := v.resourceFilter
        v.mu.RUnlock()

        text := v.formatResults(results, windowFilter, resourceFilter)

        // Need write lock when setting text to avoid race with GetText
        v.mu.Lock()
        v.view.SetText(text)
        v.mu.Unlock()
}</span>

// formatResults formats aggregation results for display
func (v *HistoryView) formatResults(results []aggregator.AggregationResult, windowFilter, resourceFilter string) string <span class="cov8" title="1">{
        if len(results) == 0 </span><span class="cov8" title="1">{
                return "[yellow]No aggregated data yet...[white]\n\n[gray]Data will appear after the first window completes.[white]"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder

        // Filter results
        var filtered []aggregator.AggregationResult
        for _, r := range results </span><span class="cov8" title="1">{
                windowStr := FormatDuration(r.WindowSize)
                if windowFilter != "" &amp;&amp; windowStr != windowFilter </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if resourceFilter != "" &amp;&amp; r.ResourceType != resourceFilter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">filtered = append(filtered, r)</span>
        }

        // Header
        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("[blue]Window: %s[white]  ", windowFilter))
        if resourceFilter != "" </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("[blue]Resource: %s[white]", resourceFilter))
        }</span>
        <span class="cov8" title="1">sb.WriteString("\n\n")

        if len(filtered) == 0 </span><span class="cov0" title="0">{
                sb.WriteString("[gray]No data matching filters[white]")
                return sb.String()
        }</span>

        // Sort by timestamp descending
        <span class="cov8" title="1">sort.Slice(filtered, func(i, j int) bool </span><span class="cov8" title="1">{
                return filtered[i].Timestamp.After(filtered[j].Timestamp)
        }</span>)

        // Show recent results (limit to 50)
        <span class="cov8" title="1">limit := 50
        if len(filtered) &lt; limit </span><span class="cov8" title="1">{
                limit = len(filtered)
        }</span>

        // Table header
        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("[green]%-12s %-15s %-10s %-8s %s[white]\n",
                "TIME", "RESOURCE", "METRIC", "TYPE", "VALUE"))
        sb.WriteString(strings.Repeat("", 70) + "\n")

        for i := 0; i &lt; limit; i++ </span><span class="cov8" title="1">{
                r := filtered[i]

                // Format value
                var valueStr string
                if strings.Contains(r.MetricName, "bytes") </span><span class="cov8" title="1">{
                        valueStr = FormatBytes(r.Value)
                }</span> else<span class="cov8" title="1"> if strings.Contains(r.MetricName, "percent") </span><span class="cov8" title="1">{
                        valueStr = fmt.Sprintf("%.1f%%", r.Value)
                }</span> else<span class="cov0" title="0"> {
                        valueStr = fmt.Sprintf("%.2f", r.Value)
                }</span>

                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%-12s %-15s %-10s %-8s %s\n",
                        r.Timestamp.Format("15:04:05"),
                        r.ResourceType,
                        truncate(r.MetricName, 10),
                        r.AggregationType,
                        valueStr,
                ))</span>
        }

        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("\n[gray]Showing %d of %d results[white]", limit, len(filtered)))

        return sb.String()</span>
}

// truncate truncates a string to max length
func truncate(s string, max int) string <span class="cov8" title="1">{
        if len(s) &lt;= max </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:max-1] + ""</span>
}

// GetText returns the current text content
func (v *HistoryView) GetText() string <span class="cov8" title="1">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.view.GetText(true)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package tui

import (
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/rivo/tview"

        "github.com/etlmon/etlmon/internal/collector"
)

// DisplayFormat represents the display format for metrics
type DisplayFormat int

const (
        FormatDetailed DisplayFormat = iota
        FormatTable
)

// RealtimeView displays real-time metrics
type RealtimeView struct {
        view           *tview.TextView
        currentMetrics []collector.Metric
        displayFormat  DisplayFormat
        mu             sync.RWMutex
}

// NewRealtimeView creates a new realtime view
func NewRealtimeView() *RealtimeView <span class="cov8" title="1">{
        view := tview.NewTextView().
                SetDynamicColors(true).
                SetScrollable(true).
                SetWrap(false)

        view.SetBorder(true).
                SetTitle(" Real-time Metrics (Press Tab to switch, Q to quit) ").
                SetTitleAlign(tview.AlignLeft)

        return &amp;RealtimeView{
                view:           view,
                currentMetrics: make([]collector.Metric, 0),
                displayFormat:  FormatDetailed,
        }
}</span>

// Update updates the view with new metrics
func (v *RealtimeView) Update(metrics []collector.Metric) <span class="cov8" title="1">{
        v.mu.Lock()
        v.currentMetrics = make([]collector.Metric, len(metrics))
        copy(v.currentMetrics, metrics)
        v.mu.Unlock()

        v.render()
}</span>

// render updates the text content
func (v *RealtimeView) render() <span class="cov8" title="1">{
        v.mu.RLock()
        metrics := make([]collector.Metric, len(v.currentMetrics))
        copy(metrics, v.currentMetrics)
        format := v.displayFormat
        v.mu.RUnlock()

        var text string
        if format == FormatDetailed </span><span class="cov8" title="1">{
                text = v.formatMetrics(metrics)
        }</span> else<span class="cov8" title="1"> {
                text = v.formatMetricsTable(metrics)
        }</span>

        // Need write lock when setting text to avoid race with GetText
        <span class="cov8" title="1">v.mu.Lock()
        v.view.SetText(text)
        v.updateTitle()
        v.mu.Unlock()</span>
}

// formatMetrics formats metrics for display
func (v *RealtimeView) formatMetrics(metrics []collector.Metric) string <span class="cov8" title="1">{
        if len(metrics) == 0 </span><span class="cov8" title="1">{
                return "[yellow]Waiting for metrics...[white]"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder

        // Group by resource type
        grouped := make(map[string][]collector.Metric)
        for _, m := range metrics </span><span class="cov8" title="1">{
                grouped[m.ResourceType] = append(grouped[m.ResourceType], m)
        }</span>

        // Sort resource types
        <span class="cov8" title="1">types := make([]string, 0, len(grouped))
        for t := range grouped </span><span class="cov8" title="1">{
                types = append(types, t)
        }</span>
        <span class="cov8" title="1">sort.Strings(types)

        for _, resourceType := range types </span><span class="cov8" title="1">{
                resourceMetrics := grouped[resourceType]

                // Header
                sb.WriteString(fmt.Sprintf("[green] %s [white]\n", strings.ToUpper(resourceType)))

                // Sort metrics by name
                sort.Slice(resourceMetrics, func(i, j int) bool </span><span class="cov8" title="1">{
                        return resourceMetrics[i].Name &lt; resourceMetrics[j].Name
                }</span>)

                <span class="cov8" title="1">for _, m := range resourceMetrics </span><span class="cov8" title="1">{
                        // Format value based on metric name
                        var valueStr string
                        if strings.Contains(m.Name, "bytes") </span><span class="cov8" title="1">{
                                valueStr = FormatBytes(m.Value)
                        }</span> else<span class="cov8" title="1"> if strings.Contains(m.Name, "percent") </span><span class="cov8" title="1">{
                                valueStr = fmt.Sprintf("%.1f%%", m.Value)
                                // Color code based on value
                                if m.Value &gt; 90 </span><span class="cov8" title="1">{
                                        valueStr = fmt.Sprintf("[red]%s[white]", valueStr)
                                }</span> else<span class="cov8" title="1"> if m.Value &gt; 70 </span><span class="cov8" title="1">{
                                        valueStr = fmt.Sprintf("[yellow]%s[white]", valueStr)
                                }</span> else<span class="cov8" title="1"> {
                                        valueStr = fmt.Sprintf("[green]%s[white]", valueStr)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                valueStr = fmt.Sprintf("%.2f", m.Value)
                        }</span>

                        // Add labels if present
                        <span class="cov8" title="1">labelStr := ""
                        if len(m.Labels) &gt; 0 </span><span class="cov8" title="1">{
                                if mp, ok := m.Labels["mountpoint"]; ok </span><span class="cov8" title="1">{
                                        labelStr = fmt.Sprintf(" [gray](%s)[white]", mp)
                                }</span>
                        }

                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("  %-20s %s%s\n", m.Name, valueStr, labelStr))</span>
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("[gray]Last updated: %s[white]", time.Now().Format("15:04:05")))

        return sb.String()</span>
}

// formatMetricsTable formats metrics as a table
func (v *RealtimeView) formatMetricsTable(metrics []collector.Metric) string <span class="cov8" title="1">{
        if len(metrics) == 0 </span><span class="cov8" title="1">{
                return "[yellow]Waiting for metrics...[white]"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder

        // Table header
        sb.WriteString(fmt.Sprintf("%-14s %-12s %-12s %-12s %-12s\n", "RESOURCE", "USAGE", "USED", "FREE", "TOTAL"))
        sb.WriteString(strings.Repeat("", 62) + "\n")

        // Group metrics by resource type and mountpoint
        type resourceKey struct {
                resourceType string
                mountpoint   string
        }
        grouped := make(map[resourceKey]map[string]float64)

        for _, m := range metrics </span><span class="cov8" title="1">{
                key := resourceKey{resourceType: m.ResourceType}
                if mp, ok := m.Labels["mountpoint"]; ok </span><span class="cov8" title="1">{
                        key.mountpoint = mp
                }</span>

                <span class="cov8" title="1">if grouped[key] == nil </span><span class="cov8" title="1">{
                        grouped[key] = make(map[string]float64)
                }</span>
                <span class="cov8" title="1">grouped[key][m.Name] = m.Value</span>
        }

        // Sort keys for consistent display
        <span class="cov8" title="1">var keys []resourceKey
        for k := range grouped </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                if keys[i].resourceType != keys[j].resourceType </span><span class="cov0" title="0">{
                        return keys[i].resourceType &lt; keys[j].resourceType
                }</span>
                <span class="cov8" title="1">return keys[i].mountpoint &lt; keys[j].mountpoint</span>
        })

        // Format each row
        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                values := grouped[key]

                // Build resource name
                resourceName := key.resourceType
                if key.mountpoint != "" </span><span class="cov8" title="1">{
                        resourceName = fmt.Sprintf("%s (%s)", key.resourceType, key.mountpoint)
                }</span>

                // Get values
                <span class="cov8" title="1">usagePercent, hasUsage := values["usage_percent"]
                usedBytes, hasUsed := values["used_bytes"]
                totalBytes, hasTotal := values["total_bytes"]

                // For memory, available_bytes is FREE
                // For disk, free_bytes is FREE
                var freeBytes float64
                var hasFree bool
                if availBytes, ok := values["available_bytes"]; ok </span><span class="cov8" title="1">{
                        freeBytes = availBytes
                        hasFree = true
                }</span> else<span class="cov8" title="1"> if free, ok := values["free_bytes"]; ok </span><span class="cov8" title="1">{
                        freeBytes = free
                        hasFree = true
                }</span>

                // Format usage with color coding
                <span class="cov8" title="1">var usageStr string
                if hasUsage </span><span class="cov8" title="1">{
                        var color string
                        if usagePercent &gt; 90 </span><span class="cov8" title="1">{
                                color = "[red]"
                        }</span> else<span class="cov8" title="1"> if usagePercent &gt; 70 </span><span class="cov8" title="1">{
                                color = "[yellow]"
                        }</span> else<span class="cov8" title="1"> {
                                color = "[green]"
                        }</span>
                        <span class="cov8" title="1">usageStr = fmt.Sprintf("%s%.1f%%[white]", color, usagePercent)</span>
                } else<span class="cov0" title="0"> {
                        usageStr = "-"
                }</span>

                // Format other columns
                <span class="cov8" title="1">var usedStr, freeStr, totalStr string
                if hasUsed </span><span class="cov8" title="1">{
                        usedStr = FormatBytes(usedBytes)
                }</span> else<span class="cov8" title="1"> {
                        usedStr = "-"
                }</span>
                <span class="cov8" title="1">if hasFree </span><span class="cov8" title="1">{
                        freeStr = FormatBytes(freeBytes)
                }</span> else<span class="cov8" title="1"> {
                        freeStr = "-"
                }</span>
                <span class="cov8" title="1">if hasTotal </span><span class="cov8" title="1">{
                        totalStr = FormatBytes(totalBytes)
                }</span> else<span class="cov8" title="1"> {
                        totalStr = "-"
                }</span>

                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%-14s %-12s %-12s %-12s %-12s\n",
                        resourceName, usageStr, usedStr, freeStr, totalStr))</span>
        }

        <span class="cov8" title="1">sb.WriteString("\n")
        sb.WriteString(fmt.Sprintf("[gray]Last updated: %s[white]", time.Now().Format("15:04:05")))

        return sb.String()</span>
}

// SetDisplayFormat sets the display format
func (v *RealtimeView) SetDisplayFormat(format DisplayFormat) <span class="cov8" title="1">{
        v.mu.Lock()
        v.displayFormat = format
        v.mu.Unlock()
}</span>

// ToggleDisplayFormat switches between display formats
func (v *RealtimeView) ToggleDisplayFormat() <span class="cov8" title="1">{
        v.mu.Lock()
        if v.displayFormat == FormatDetailed </span><span class="cov8" title="1">{
                v.displayFormat = FormatTable
        }</span> else<span class="cov8" title="1"> {
                v.displayFormat = FormatDetailed
        }</span>
        <span class="cov8" title="1">v.mu.Unlock()
        v.render()</span>
}

// GetDisplayFormat returns the current display format
func (v *RealtimeView) GetDisplayFormat() DisplayFormat <span class="cov8" title="1">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.displayFormat
}</span>

// updateTitle updates the view title based on display format
func (v *RealtimeView) updateTitle() <span class="cov8" title="1">{
        var title string
        if v.displayFormat == FormatDetailed </span><span class="cov8" title="1">{
                title = " Real-time Metrics [Detailed] (Tab: History | T: Table | Q: Quit) "
        }</span> else<span class="cov8" title="1"> {
                title = " Real-time Metrics [Table] (Tab: History | T: Detailed | Q: Quit) "
        }</span>
        <span class="cov8" title="1">v.view.SetTitle(title)</span>
}

// GetText returns the current text content
func (v *RealtimeView) GetText() string <span class="cov8" title="1">{
        v.mu.RLock()
        defer v.mu.RUnlock()
        return v.view.GetText(true)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package tui

import (
        "fmt"
        "sync"
        "time"

        "github.com/rivo/tview"
)

// StatusBar displays status information
type StatusBar struct {
        view       *tview.TextView
        status     string
        lastUpdate time.Time
        mu         sync.RWMutex
}

// NewStatusBar creates a new status bar
func NewStatusBar() *StatusBar <span class="cov8" title="1">{
        view := tview.NewTextView().
                SetDynamicColors(true).
                SetTextAlign(tview.AlignCenter)

        return &amp;StatusBar{
                view:   view,
                status: "Initializing...",
        }
}</span>

// SetStatus sets the status message
func (s *StatusBar) SetStatus(status string) <span class="cov8" title="1">{
        s.mu.Lock()
        s.status = status
        s.mu.Unlock()
        s.render()
}</span>

// SetLastUpdate sets the last update time
func (s *StatusBar) SetLastUpdate(t time.Time) <span class="cov8" title="1">{
        s.mu.Lock()
        s.lastUpdate = t
        s.mu.Unlock()
        s.render()
}</span>

// render updates the status bar text
func (s *StatusBar) render() <span class="cov8" title="1">{
        s.mu.RLock()
        status := s.status
        lastUpdate := s.lastUpdate
        s.mu.RUnlock()

        var text string
        if lastUpdate.IsZero() </span><span class="cov8" title="1">{
                text = fmt.Sprintf("[green]%s[white] | [gray]etlmon[white]", status)
        }</span> else<span class="cov8" title="1"> {
                text = fmt.Sprintf("[green]%s[white] | Last: %s | [gray]etlmon[white]",
                        status, lastUpdate.Format("15:04:05"))
        }</span>

        // Need write lock when setting text to avoid race with GetText
        <span class="cov8" title="1">s.mu.Lock()
        s.view.SetText(text)
        s.mu.Unlock()</span>
}

// GetText returns the current status text
func (s *StatusBar) GetText() string <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.view.GetText(true)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
